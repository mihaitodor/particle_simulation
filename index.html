<!DOCTYPE html>

<html>

<head>
	<meta charset="UTF-8">
	<title>Particle Simulation</title>

<style>
	* {
		margin: 0;
	}

	html, body {
		height: 100%;
	}

	.container {
		height: 100%;
		margin: 0px auto;
		overflow: hidden;
    }

    #animation {
    	display: block;
    	height: 100%;
    	width: 100%;
    }

    canvas {
		display: block; /* The default display, inline, would add small margin below the canvas */
		height: 100%;
		width: 100%;
	}
</style>

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/stats.min.js"></script>

<script>
	"use strict";

	console.clear();

	// Handles which need to be accessed when rendering frames
	let scene, camera, renderer, controls, stats;

	// Animated objects
	let sphereOfInfluence;

	function updateObjects() {
		sphereOfInfluence.rotation.y += 0.005;
	}

	function render() {
		requestAnimationFrame(render);

		updateObjects();

		renderer.render(scene, camera);
		controls.update();
		stats.update();
	}

	function init() {
		scene = new THREE.Scene();
		scene.background = new THREE.Color('white')
		camera = new THREE.PerspectiveCamera();
		camera.position.z = 1.7;
		camera.position.x = 0.7;
		camera.position.y = 0.1;

		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio);

		let animationContainer = document.getElementById('animation');
		animationContainer.appendChild(renderer.domElement);

		stats = new Stats();
		animationContainer.appendChild(stats.dom);

		let bbClientRect = renderer.domElement.getBoundingClientRect();
		camera.aspect = bbClientRect.width / bbClientRect.height;
		camera.updateProjectionMatrix();
		renderer.setSize( bbClientRect.width, bbClientRect.height );
		window.addEventListener('resize', function() {
			renderer.setSize(animationContainer.offsetWidth, animationContainer.offsetHeight);
		});

		controls = new THREE.OrbitControls(camera, renderer.domElement);
		//controls.enableZoom = false;

		let box = new THREE.Mesh(
			new THREE.BoxBufferGeometry(1, 1, 1),
			new THREE.MeshBasicMaterial({ color: new THREE.Color('red'), transparent: true, opacity: 0.1 })
		);
		let boxEdges = new THREE.LineSegments(
			new THREE.EdgesGeometry(box.geometry), // or WireframeGeometry
			new THREE.LineBasicMaterial({ color: new THREE.Color('red') })
		);
		box.add(boxEdges);
		scene.add(box);

		sphereOfInfluence = new THREE.Mesh(
			new THREE.SphereGeometry(0.2),
			new THREE.MeshBasicMaterial({ color: new THREE.Color('blue'), transparent: true, opacity: 0.0 })
		);
		let sphereOfInfluenceEdges = new THREE.LineSegments(
			new THREE.EdgesGeometry(sphereOfInfluence.geometry), // or WireframeGeometry
			new THREE.LineBasicMaterial({ color: new THREE.Color('blue') })
		);
		sphereOfInfluence.add(sphereOfInfluenceEdges);
		box.add(sphereOfInfluence);

		let target = new THREE.Mesh(
			new THREE.SphereGeometry(0.1, 30, 30),
			new THREE.MeshBasicMaterial({ color: new THREE.Color('green')})
		);
		sphereOfInfluence.add(target);

		render();
	}

</script>
</head>

<body onload="init()">
	<div class="container">
		<div id="animation"></div>
		<div id="chart"></div>
	</div>
</body>
</html>