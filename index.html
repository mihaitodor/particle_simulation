<!DOCTYPE html>

<html>

<head>
	<meta charset="UTF-8">
	<title>Particle Simulation</title>

<style>
	* {
		margin: 0;
	}

	html, body {
		height: 100%;
	}

	.container {
		height: 100%;
		margin: 0px auto;
		overflow: hidden;
    }

    #animation {
    	display: block;
    	height: 100%;
    	width: 100%;
    }

    canvas {
		display: block; /* The default display, inline, would add small margin below the canvas */
		height: 100%;
		width: 100%;
	}
</style>

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/stats.min.js"></script>

<script>
	"use strict";

	console.clear();

	const DIMENSIONS = 1;
	const CYLINDER_HEIGHT = 0.2;

	const PARTICLE_COUNT = 2000;
	const PARTICLE_VELOCITY_MAX = DIMENSIONS / 128;
	const PARTICLE_VELOCITY_MIN = DIMENSIONS / 1280;
	const PARTICLES_DELAY = 15;
	const PARTICLES_BATCH_SIZE = 100;
	const PARTICLE_BATCHES = ~~(PARTICLE_COUNT / PARTICLES_BATCH_SIZE);

	// Handles which need to be accessed when rendering frames
	let scene, camera, renderer, controls, stats;

	// Animated objects
	let sphereOfInfluence, particles = [], visibleParticles = [];

	// Keep track of elapsed frames
	let elapsed = 0;

	// Check to see if the position of the ball doesn't go past the box wall and
	// also check to see if it's velocity is less than or greater than 0 so it
	// doesn't spike past and get stuck by the edge of the wall.
	function checkWallBoundaries(current) {
	    if(current.position.x >= DIMENSIONS / 2 - current.geometry.parameters.radius && current.velocity.x > 0 || current.position.x <= -DIMENSIONS / 2 + current.geometry.parameters.radius && current.velocity.x < 0)
	        current.velocity.setX(-current.velocity.x);

	    if(current.position.y >= DIMENSIONS / 2 - current.geometry.parameters.radius && current.velocity.y > 0 || current.position.y <= -DIMENSIONS / 2 + current.geometry.parameters.radius && current.velocity.y < 0)
	        current.velocity.setY(-current.velocity.y);

	    if(current.position.z >= DIMENSIONS / 2 - current.geometry.parameters.radius && current.velocity.z > 0 || current.position.z <= -DIMENSIONS / 2 + current.geometry.parameters.radius && current.velocity.z < 0)
	        current.velocity.setZ(-current.velocity.z);
	}

	function updateObjects() {
		sphereOfInfluence.rotation.y += 0.005;

		for (let i = 0; i < particles.length; i++) {
			if (particles[i].batch * PARTICLES_DELAY <= elapsed) {
				particles[i].visible = true;
				particles[i].position.add(particles[i].velocity);
				checkWallBoundaries(particles[i]);
			}
		}
/*
		if (elapsed >= PARTICLE_BATCHES * PARTICLES_DELAY) {
			for (let i = 0; i < particles.length - PARTICLES_BATCH_SIZE; i++) {
				particles[i].batch += 1;
			}

			for (let i = particles.length - PARTICLES_BATCH_SIZE; i < particles.length; i++) {
				particles[i].batch = 0;
				// particles[i].visible = false;
				// particles[i].position.x = -DIMENSIONS / 2;
				// particles[i].position.y = 0;
				// particles[i].position.z = 0;
			}

			//elapsed = 0;
		}
*/
	}

	function renderLoop() {
		requestAnimationFrame(renderLoop);

		updateObjects();

		renderer.render(scene, camera);
		controls.update();
		stats.update();

		elapsed += 1;
	}

	function init() {
		scene = new THREE.Scene();
		scene.background = new THREE.Color('white')

		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio);

		let animationContainer = document.getElementById('animation');
		animationContainer.appendChild(renderer.domElement);

		stats = new Stats();
		animationContainer.appendChild(stats.dom);

		let bbClientRect = renderer.domElement.getBoundingClientRect();
		// Use the default values from the PerspectiveCamera constructor
		camera = new THREE.PerspectiveCamera(50, bbClientRect.width / bbClientRect.height, 0.1, 2000);
		camera.position.z = DIMENSIONS * 2;
		camera.position.x = DIMENSIONS * 0.7;
		camera.position.y = DIMENSIONS * 0.1;
		camera.updateProjectionMatrix();

		renderer.setSize( bbClientRect.width, bbClientRect.height );
		window.addEventListener('resize', function() {
			renderer.setSize(animationContainer.offsetWidth, animationContainer.offsetHeight);
		});

		controls = new THREE.OrbitControls(camera, renderer.domElement);
		//controls.enableZoom = false;

		let box = new THREE.Mesh(
			new THREE.BoxBufferGeometry(DIMENSIONS, DIMENSIONS, DIMENSIONS),
			new THREE.MeshBasicMaterial({ color: new THREE.Color('red'), transparent: true, opacity: 0.1, depthTest: false })
		);
		let boxEdges = new THREE.LineSegments(
			new THREE.EdgesGeometry(box.geometry), // or WireframeGeometry
			new THREE.LineBasicMaterial({ color: new THREE.Color('red') })
		);
		box.add(boxEdges);
		scene.add(box);

		sphereOfInfluence = new THREE.Mesh(
			new THREE.SphereGeometry(DIMENSIONS * 0.2),
			new THREE.MeshDepthMaterial({ wireframe: true })
		);

		box.add(sphereOfInfluence);

		let target = new THREE.Mesh(
			new THREE.SphereGeometry(DIMENSIONS * 0.1, 30, 30),
			new THREE.MeshBasicMaterial	({
				color: new THREE.Color('black'),
				transparent: true,
				opacity: 0.6
			})
		);
		sphereOfInfluence.add(target);


		var input = new THREE.Mesh(
			new THREE.CylinderGeometry(0.05, 0.05, CYLINDER_HEIGHT, 8, 1, false, 0.0, Math.PI * 2),
			new THREE.MeshBasicMaterial( {color: new THREE.Color('red'), transparent: true, opacity: 0.5 } )
		);
		input.position.x = -DIMENSIONS / 2 - CYLINDER_HEIGHT / 2;
		input.rotation.x = Math.PI / 2;
		input.rotation.z = Math.PI / 2;
		let inputEdges = new THREE.LineSegments(
			new THREE.WireframeGeometry(input.geometry), // or EdgesGeometry
			new THREE.LineBasicMaterial({ color: new THREE.Color('red') })
		);
		input.add(inputEdges);
		scene.add(input);

		var output = new THREE.Mesh(
			new THREE.CylinderGeometry(0.05, 0.05, CYLINDER_HEIGHT, 8, 1, false, 0.0, Math.PI * 2),
			new THREE.MeshBasicMaterial( {color: new THREE.Color('red'), transparent: true, opacity: 0.5 } )
		);
		output.position.x = DIMENSIONS / 2 + CYLINDER_HEIGHT / 2;
		output.rotation.x = Math.PI / 2;
		output.rotation.z = Math.PI / 2;
		let outputEdges = new THREE.LineSegments(
			new THREE.WireframeGeometry(output.geometry), // or EdgesGeometry
			new THREE.LineBasicMaterial({ color: new THREE.Color('red') })
		);
		output.add(outputEdges);
		scene.add(output);

		// Create particles
		let geometry = new THREE.SphereGeometry(DIMENSIONS * 0.005, 32, 32);
		let material = new THREE.MeshBasicMaterial({
			color: new THREE.Color('red')
		});

		for (let batch = 0; batch < PARTICLE_BATCHES; batch++) {
			for (let i = 0; i < PARTICLES_BATCH_SIZE; i++) {
				let particle = new THREE.Mesh(geometry, material);
				// Inject particles from the centre of the left side face of the box
				particle.position.x = -DIMENSIONS / 2;

				particle.velocity = new THREE.Vector3(
					(Math.random() - 0.5) * 2 * (PARTICLE_VELOCITY_MAX - PARTICLE_VELOCITY_MIN) + PARTICLE_VELOCITY_MIN,
					(Math.random() - 0.5) * 2 * (PARTICLE_VELOCITY_MAX - PARTICLE_VELOCITY_MIN) + PARTICLE_VELOCITY_MIN,
					(Math.random() - 0.5) * 2 * (PARTICLE_VELOCITY_MAX - PARTICLE_VELOCITY_MIN) + PARTICLE_VELOCITY_MIN
				);

				particle.visible = false;

				particle.batch = batch;

				particles.push(particle);
				scene.add(particle);
			}
		}

		//https://mihaitodor.github.io/particle_simulation/textures/particle.png

		renderLoop();
	}

</script>
</head>

<body onload="init()">
	<div class="container">
		<div id="animation"></div>
		<div id="chart"></div>
	</div>
</body>
</html>