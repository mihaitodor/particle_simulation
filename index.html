<!DOCTYPE html>

<html>

<head>
<meta charset="UTF-8">
<title>Particle Simulation</title>

<script src="js/three.js-r108/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/stats.js-r17/stats.min.js"></script>
<script src="js/dat.gui-0.7.6/dat.gui.min.js"></script>
<script src="js/d3-5.11.0/d3.min.js" charset="utf-8"></script>
<script src="js/c3-0.7.8/c3.js"></script>

<link href="js/c3-0.7.8/c3.min.css" rel="stylesheet">

<style>
* {
	margin: 0;
}

html, body {
	height: 100%;
}

.container {
	position: relative;
	height: 100%;
	margin: 0px auto;
	overflow: hidden;
}

#animation {
	position: absolute;
	height: 100%;
	width: 100%;
}

#animation canvas {
	display: block; /* The default display, inline, would add small margin below the canvas */
	height: 100%;
	width: 100%;
}

.chart-container {
	position: absolute;
	width: 35%;
	height: 50%;
	left: 0;
	bottom: 25%;
}

.dg
.dg input,
.dg .title,
.dg .close-button,
.dg .property-name,
.dg .save-row select,
.dg .save-row .button {
	font-size: 15px !important;
}

.dg .c input[type=text] {
	padding-top: 0px;
	padding-bottom: 2px;
	height: 17px;
}

.dg .cr.number input[type=text] {
    color: white;
}

.dg .save-row {
	line-height: 30px !important;
}

.dg .save-row select {
	width: 152px !important;
}

.dg li.save-row .button {
	color: black;
	background: white;
}

.dg li.save-row .button.gears {
	color: black;
	background: white;
	background-size: 13px;
	background-repeat: no-repeat;
	background-position: center;
	background-image:
		url("data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='16' height='16' viewBox='0 0 16 16'><path d='M14.59 9.535c-0.839-1.454-0.335-3.317 1.127-4.164l-1.572-2.723c-0.449 0.263-0.972 0.414-1.529 0.414-1.68 0-3.042-1.371-3.042-3.062h-3.145c0.004 0.522-0.126 1.051-0.406 1.535-0.839 1.454-2.706 1.948-4.17 1.106l-1.572 2.723c0.453 0.257 0.845 0.634 1.123 1.117 0.838 1.452 0.336 3.311-1.12 4.16l1.572 2.723c0.448-0.261 0.967-0.41 1.522-0.41 1.675 0 3.033 1.362 3.042 3.046h3.145c-0.001-0.517 0.129-1.040 0.406-1.519 0.838-1.452 2.7-1.947 4.163-1.11l1.572-2.723c-0.45-0.257-0.839-0.633-1.116-1.113zM8 11.24c-1.789 0-3.24-1.45-3.24-3.24s1.45-3.24 3.24-3.24c1.789 0 3.24 1.45 3.24 3.24s-1.45 3.24-3.24 3.24z'></path></svg>");
}

.dg li.save-row .button.gears:hover {
	background-color: #bab19e;
}

.info-wrapper {
	position: fixed;
	display: none;
	z-index: 1;
	opacity: 0;
	background-color: rgba(0, 0, 0, 0.8);
	top: 0px;
	left: 0px;
	right: 0px;
	bottom: 0px;
	transition: opacity .2s linear;
}

#info {
	position: fixed;
	display: none;
	z-index: 2;
	opacity: 0;
	left: 50%;
	top: 50%;
	transform: translate(-50%, -50%) scale(1.1);
	width: 460px;
	padding: 15px;
	color: #eee;
	background-color: #222;
	font: 13px 'Lucida Grande', sans-serif;
	white-space: pre-line;
	transition: transform .2s ease-out 0s, opacity .2s linear 0s;
}

#info a {
	color: #0000ee;
	display: inline-block;
	position: relative;
	text-decoration: none;
}

#info a:before {
	background-color: #0000ee;
	content: '';
	height: 2px;
	position: absolute;
	bottom: -2px;
	transition: width 0.3s ease-in-out;
	width: 100%;
}

#info a:hover:before {
	width: 0;
}

#info button {
	margin: 0 auto;
	display: block;
}

</style>

<!--
Chart styles inspired from here: https://github.com/c3js/c3/issues/210#issuecomment-353671994
Please keep one rule per style element, since they will be updated dynamically in adjustColors()
-->
<style id="chart-axes-color">
.chart-container .c3 .c3-axis-x path,
.chart-container .c3 .c3-axis-x line,
.chart-container .c3 .c3-axis-y path,
.chart-container .c3 .c3-axis-y line {
}
</style>

<style id="chart-text-elements-color">
.chart-container .c3 .c3-title,
.chart-container .c3 .c3-axis-x g,
.chart-container .c3 .c3-axis-y g,
.chart-container .c3 .c3-axis-y-label,
.chart-container .c3 .c3-axis-x-label {
}
</style>

<style id="chart-legend-body-text-color">
.chart-container .c3 .c3-legend-item-body text {
}
</style>

<style id="chart-legend-target-text-color">
.chart-container .c3 .c3-legend-item-target text {
}
</style>

<style id="c3-title-text-size">
.chart-container .c3 .c3-title {
	font-size: 150%;
}
</style>

<style id="c3-axis-label-text-size">
.chart-container .c3 .c3-axis .c3-axis-x-label,
.chart-container .c3 .c3-axis .c3-axis-y-label {
	font-size: 150%;
}
</style>

<style id="c3-axis-tick-text-size">
.chart-container .c3 .c3-axis text {
  font-size: 175%;
}
</style>

<style id="c3-data-target-line-stroke">
.chart-container .c3 .c3-target-target {
	stroke-dasharray: 5;
}
</style>

<style id="c3-legend-target-tile-stroke">
.chart-container .c3 .c3-legend-item-target .c3-legend-item-tile {
	stroke-dasharray: 5;
}
</style>

<script>
	"use strict";

	let presets = {
		"preset": "Sim-1",
		"remembered": {
			"Sim-1": {
				"0": {},
				"1": {},
				"2": {},
				"3": {
					"width": 0.6,
					"height": 1.6,
					"depth": 0.4
				},
				"4": {
					"radius": 0.08,
					"cageEnabled": false
				},
				"5": {
					"radius": 0.04
				},
				"6": {},
				"7": {
					"changeColor": false,
					"particlesInvisibleInBox": false,
					"radius": 0.004,
					"count": 5000
				},
				"8": {},
				"9": {},
				"10": {
					"initialDelay": 250,
					"rate": 50
				},
				"11": {
					"initialDelay": 500,
					"rate": 25
				}
			},
			"Sim-2": {
				"0": {},
				"1": {},
				"2": {},
				"3": {
					"width": 0.6,
					"height": 1.6,
					"depth": 0.4
				},
				"4": {
					"radius": 0.08,
					"cageEnabled": false
				},
				"5": {
					"radius": 0.04
				},
				"6": {},
				"7": {
					"changeColor": false,
					"particlesInvisibleInBox": false,
					"radius": 0.004,
					"count": 5000
				},
				"8": {},
				"9": {},
				"10": {
					"initialDelay": 250,
					"rate": 25
				},
				"11": {
					"initialDelay": 750,
					"rate": 10
				}
			},
			"Sim-3": {
				"0": {},
				"1": {},
				"2": {},
				"3": {
					"width": 0.6,
					"height": 1.6,
					"depth": 0.4
				},
				"4": {
					"radius": 0.08,
					"cageEnabled": false
				},
				"5": {
					"radius": 0.04
				},
				"6": {},
				"7": {
					"changeColor": true,
					"particlesInvisibleInBox": false,
					"radius": 0.004,
					"count": 5000
				},
				"8": {},
				"9": {},
				"10": {
					"initialDelay": 250,
					"rate": 50
				},
				"11": {
					"initialDelay": 500,
					"rate": 20
				}
			},
			"Sim-4": {
				"0": {},
				"1": {},
				"2": {},
				"3": {
					"width": 0.6,
					"height": 1.6,
					"depth": 0.4
				},
				"4": {
					"radius": 0.08,
					"cageEnabled": false
				},
				"5": {
					"radius": 0.04
				},
				"6": {},
				"7": {
					"changeColor": true,
					"particlesInvisibleInBox": false,
					"radius": 0.003,
					"count": 5000
				},
				"8": {},
				"9": {},
				"10": {
					"initialDelay": 250,
					"rate": 25
				},
				"11": {
					"initialDelay": 750,
					"rate": 10
				}
			},
			"Sim-5": {
				"0": {},
				"1": {},
				"2": {},
				"3": {
					"width": 0.6,
					"height": 1.6,
					"depth": 0.4
				},
				"4": {
					"radius": 0.08,
					"cageEnabled": true
				},
				"5": {
					"radius": 0.04
				},
				"6": {},
				"7": {
					"changeColor": false,
					"particlesInvisibleInBox": false,
					"radius": 0.004,
					"count": 5000
				},
				"8": {},
				"9": {},
				"10": {
					"initialDelay": 250,
					"rate": 25
				},
				"11": {
					"initialDelay": 750,
					"rate": 10
				}
			},
			"Sim-6": {
				"0": {},
				"1": {},
				"2": {},
				"3": {
					"width": 0.6,
					"height": 1.6,
					"depth": 0.4
				},
				"4": {
					"radius": 0.08,
					"cageEnabled": true
				},
				"5": {
					"radius": 0.04
				},
				"6": {},
				"7": {
					"changeColor": true,
					"particlesInvisibleInBox": false,
					"radius": 0.004,
					"count": 5000
				},
				"8": {},
				"9": {},
				"10": {
					"initialDelay": 250,
					"rate": 25
				},
				"11": {
					"initialDelay": 750,
					"rate": 10
				}
			}
		}
	};

	const originalPresets = Object.keys(presets.remembered);

	const SCENE_SCALE = 1;

	let Config = function() {
		this.scene = {
			background: {
				color: getGuiColorString('black'),
			},
			box: {
				color: '#c7c9d2',
				edgesColor: '#f7ebeb',
				opacity: 0.3,
				width: 0.6,
				height: 1.6,
				depth: 0.4,
			},
			targetCage: {
				color: getGuiColorString('gray'),
				opacity: 0.2,
				radius: 0.08,
				viscosity: 0.9,
				rotationSpeed: 0.005,
				particleCaptureProbability: 0.5,
				gravity: 0.05,
				cageEnabled: false,
			},
			target: {
				x: 0,
				y: 0,
				z: 0,
				color: getGuiColorString('red'),
				opacity: 0.07,
				radius: 0.04,
				viscosity: 0.155,
				shininess: 50,
				emissiveColor: getGuiColorString('springgreen'),
				emissiveIntensityMax: 2,
			},
			tubes: {
				color: '#e8cdcd',
				edgesColor: '#edcaca',
				height: 0.2,
				radius: 0.015,
				verticalDisplacement: 0.75,
			},
			particles: {
				color: '#00a4ff',
				changeColor: false,
				particlesInvisibleInBox: false,
				colorInTarget: getGuiColorString('red'),
				radius: 0.004,
				opacityInBox: 0.15,
				count: 5000,
				batchSize: 100,
				batchDelay: 5,
				velocityMin: SCENE_SCALE / 1000,
				velocityMax: SCENE_SCALE / 100,
			},
		};

		this.chart = {
			bodyPlotColor: getGuiColorString('white'),
			targetPlotColor: getGuiColorString('yellow'),
			axesColor: getGuiColorString('white'),
			textElementsColor: getGuiColorString('white'),
			showPoints: true,
			sampleInterval: 30,
			transitionDuration: 130,
			exclusivePlots: true,
		};

		this.gui = {
			width: 380,
		};

		this.excretion = {
			initialDelay: 250,
			rate: 50,
			delay: 20,
		};

		this.targetExcretion = {
			initialDelay: 500,
			rate: 25,
			delay: 40,
		};
	};

	// Handles which need to be accessed when rendering frames
	let animationFrame, scene, camera, renderer, controls, stats, gui, chart, config;

	// Scene objects
	let box, boxEdges, targetCage, target, inputTube, inputTubeEdges, outputTube, outputTubeEdges, particles = [], particleBatches = [], visibleParticles = [], particlesInBox = 0, particlesInTarget = 0, currentParticleBatch = 0;

	// GUI controls that need to be refreshed when adjusting sizes
	let guiTargetCageRadius, guiTargetRadius, guiTargetX, guiTargetY, guiTargetZ;

	// Keep track of elapsed frames
	let elapsed = 0;

	// Hack: Attach pauseAnimation to the `window` global, so we
	// can pass the `window` object to gui.add()
	window.pauseAnimation = false;

	function getGuiColorString(color) {
		return '#' + new THREE.Color(color).getHexString();
	};

	// Return a random value in interval [-max, -min) \cup [min, max)
	function getRandomValueWithGap(min, max, positiveOnly = false) {
		let rand = Math.random();

		let value = rand * (max - min) + min;

		// 4294967296 = 2^32
		if (positiveOnly || ((rand * 4294967296) & 1) > 0) {
			return value;
		}

		return -value;
	};

	function getRandomVelocity() {
		return new THREE.Vector3(
			getRandomValueWithGap(config.scene.particles.velocityMin, config.scene.particles.velocityMax, true),
			getRandomValueWithGap(config.scene.particles.velocityMin, config.scene.particles.velocityMax),
			getRandomValueWithGap(config.scene.particles.velocityMin, config.scene.particles.velocityMax),
		);
	}

	// Check to see if the position of the particle doesn't go past the box wall
	// and also check to see if it's velocity is less than or greater than 0 so
	// it doesn't spike past and get stuck by the edge of the wall.
	function handleBoxWallColisions(p) {
		if(p.position.x >= box.geometry.parameters.width / 2 - p.geometry.parameters.radius && p.velocity.x > 0 || p.position.x <= -box.geometry.parameters.width / 2 + p.geometry.parameters.radius && p.velocity.x < 0)
			p.velocity.setX(-p.velocity.x);

		if(p.position.y >= box.geometry.parameters.height / 2 - p.geometry.parameters.radius && p.velocity.y > 0 || p.position.y <= -box.geometry.parameters.height / 2 + p.geometry.parameters.radius && p.velocity.y < 0)
			p.velocity.setY(-p.velocity.y);

		if(p.position.z >= box.geometry.parameters.depth / 2 - p.geometry.parameters.radius && p.velocity.z > 0 || p.position.z <= -box.geometry.parameters.depth / 2 + p.geometry.parameters.radius && p.velocity.z < 0)
			p.velocity.setZ(-p.velocity.z);
	}

	// Pass collisionProbability=1 to not skip any collision
	function handleSphereWallColisions(sphere, p, collisionProbability) {
		if (collisionProbability < 1 && Math.random() < (1 - collisionProbability)) {
			return;
		}

		if (sphere.geometry.boundingSphere.distanceToPoint(p.position) > 0) {
			let normal = new THREE.Vector3();
			normal.subVectors(p.position, sphere.geometry.boundingSphere.center).normalize();
			p.velocity = p.velocity.reflect(normal);
		}
	}

	function excreteParticle(p) {
		p.isInTarget = false;
		p.isExcreted = true;
		p.visible = true;
		p.material.opacity = 1;

		p.position.x = box.geometry.parameters.width / 2 + config.scene.tubes.height;
		p.position.y = -config.scene.box.height / 2 * config.scene.tubes.verticalDisplacement;
		p.position.z = 0;

		p.velocity = getRandomVelocity();
	}

	function updateObjects() {
		if (window.pauseAnimation) {
			return;
		}

		if (config.scene.targetCage.cageEnabled) {
			targetCage.rotation.y += config.scene.targetCage.rotationSpeed;
		}

		// Release a new batch of particles
		if (elapsed % config.scene.particles.batchDelay === 0 && currentParticleBatch < particleBatches.length) {
			let batch = particleBatches[currentParticleBatch];

			for (let i = 0; i < batch.length; i++) {
				let p = batch[i];
				p.visible = !config.scene.particles.particlesInvisibleInBox;
				p.position.add(p.velocity); // Start moving the particles as soon as they become visible
				visibleParticles.push(p);
			}

			particlesInBox += batch.length;

			currentParticleBatch++;
		}

		// Set the number of particles that need to be excreted during this iteration.
		// We might not have that many left, so we handle this case gracefully in the loop below.
		let particlesToExcreteFromBox = 0;
		let particlesToExcreteFromTarget = 0;
		if (elapsed > config.excretion.initialDelay && elapsed % config.excretion.delay === 0) {
			particlesToExcreteFromBox = config.excretion.rate;
		}
		if (elapsed > config.targetExcretion.initialDelay && elapsed % config.targetExcretion.delay === 0) {
			particlesToExcreteFromTarget = config.targetExcretion.rate;
		}

		// Animate particles
		for (let i = 0; i < visibleParticles.length; i++) {
			let p = visibleParticles[i];

			if (p.isInTarget || target.geometry.boundingSphere.containsPoint(p.position)) {
				if (!p.isInTarget) {
					p.isInTarget = true;
					p.visible = true;
					p.material.opacity = 1;
					if (config.scene.particles.changeColor) {
						p.material.color.set(config.scene.particles.colorInTarget);
					}
					particlesInTarget++;
					particlesInBox--;
				}

				p.position.addScaledVector(p.velocity, 1 - config.scene.target.viscosity);

				handleSphereWallColisions(target, p, 1);

				if (particlesToExcreteFromTarget > 0) {
					excreteParticle(p);

					particlesInTarget--;

					particlesToExcreteFromTarget--;
				}
			} else {
				// Check if we leaked any particles from the target and update them accordingly.
				// This situation doesn't occur in the current model.
				if (p.isInTarget) {
					p.isInTarget = false;
					p.material.color.set(config.scene.particles.color);
					particlesInTarget--;
					particlesInBox++;
				}

				if (config.scene.targetCage.cageEnabled && (targetCage.geometry.boundingSphere.containsPoint(p.position))) {
					p.visible = true;

					// Get the vector from the target center to the particle
					let positionDirection = target.position.clone().sub(p.position);

					let depthInCage = config.scene.targetCage.radius - p.position.length();

					// Simulate gravity
					let l = p.velocity.length();
					positionDirection.multiplyScalar(depthInCage * config.scene.targetCage.gravity);
					p.velocity.add(positionDirection);
					p.velocity.normalize().multiplyScalar(l);

					// Simulate viscosity
					p.position.addScaledVector(p.velocity, (1 - config.scene.targetCage.viscosity));

					handleSphereWallColisions(targetCage, p, config.scene.targetCage.particleCaptureProbability);
				} else {
					// Inside or outside the box

					// Remove if too far away
					if (p.position.length() > config.scene.box.width * 2) {
						p.visible = false;
					} else {
						p.position.add(p.velocity);
						if (config.scene.targetCage.cageEnabled && !p.isExcreted && !targetCage.geometry.boundingSphere.containsPoint(p.position)) {
							p.visible = !config.scene.particles.particlesInvisibleInBox;
							p.material.opacity = config.scene.particles.opacityInBox;
						}
					}
				}

				if (!p.isExcreted) {
					handleBoxWallColisions(p);

					if (particlesToExcreteFromBox > 0) {
						excreteParticle(p);

						particlesInBox--;

						particlesToExcreteFromBox--;
					}
				}
			}
		}

		// Handle target glow
		target.material.emissiveIntensity = config.scene.target.emissiveIntensityMax / config.scene.particles.count * particlesInTarget;

		// Add datapoints to chart
		if ((particlesInBox > 0 || particlesInTarget > 0) && elapsed % config.chart.sampleInterval == 0) {
			let bodyValue = config.chart.exclusivePlots ? particlesInBox : (particlesInBox + particlesInTarget);
			chart.flow({
				columns: [
					['body', bodyValue / config.scene.particles.count * 100],
					['target', particlesInTarget / config.scene.particles.count * 100],
				],
				length: 0,
			});
		}

		// Advance to the next frame
		elapsed += 1;
	}

	function renderLoop() {
		animationFrame = window.requestAnimationFrame(renderLoop);

		updateObjects();

		renderer.render(scene, camera);
		controls.update();
		stats.update();
	}

	function adjustColors() {
		scene.background = new THREE.Color(config.scene.background.color);

		box.material.color.set(config.scene.box.color);
		boxEdges.material.color.set(config.scene.box.edgesColor);

		targetCage.material.color.set(config.scene.targetCage.color);

		target.material.color.set(config.scene.target.color);
		target.material.emissive.set(config.scene.target.emissiveColor);

		inputTube.material.color.set(config.scene.tubes.color);
		inputTubeEdges.material.color.set(config.scene.tubes.edgesColor);
		outputTube.material.color.set(config.scene.tubes.color);
		outputTubeEdges.material.color.set(config.scene.tubes.edgesColor);

		for (let i = 0; i < particles.length; i++) {
			let p = particles[i];
			if (p.isInTarget && config.scene.particles.changeColor) {
				p.material.color.set(config.scene.particles.colorInTarget);
			} else if (config.scene.particles.changeColor) {
				p.material.color.set(config.scene.particles.color);
			} else {
				// Use colorInTarget if changeColor is unchecked
				p.material.color.set(config.scene.particles.colorInTarget);
			}
		}

		document.getElementById("chart-axes-color").sheet.cssRules[0].style.stroke = config.chart.axesColor;
		document.getElementById("chart-text-elements-color").sheet.cssRules[0].style.fill = config.chart.textElementsColor;
		document.getElementById("chart-legend-body-text-color").sheet.cssRules[0].style.fill = config.chart.bodyPlotColor;
		document.getElementById("chart-legend-target-text-color").sheet.cssRules[0].style.fill = config.chart.targetPlotColor;
	}

	function toggleParticlesInBoxVisibility() {
		for (let i = 0; i < visibleParticles.length; i++) {
			let p = particles[i];

			if (!p.isInTarget && !p.isExcreted) {
				p.visible = !config.scene.particles.particlesInvisibleInBox;
			}
		}
	}

	function adjustOpacities() {
		adjustColors();

		box.material.opacity = config.scene.box.opacity;
		targetCage.material.opacity = config.scene.targetCage.opacity;
		target.material.opacity = config.scene.target.opacity;

		for (let i = 0; i < particles.length; i++) {
			let p = particles[i];
			if (!p.isInTarget && !p.isExcreted) {
				p.material.transparent = config.scene.particles.changeColor
				p.material.opacity = config.scene.particles.opacityInBox;
			}
		}
	}

	function adjustTargetShininess() {
		target.material.shininess = config.scene.target.shininess;
	}

	function adjustTargetPosition() {
		// Moving the target implies moving the cage as well
		targetCage.position.setX(config.scene.target.x);
		targetCage.position.setY(config.scene.target.y);
		targetCage.position.setZ(config.scene.target.z);
		targetCage.geometry.boundingSphere.center = targetCage.position;

		target.position.setX(config.scene.target.x);
		target.position.setY(config.scene.target.y);
		target.position.setZ(config.scene.target.z);
		target.geometry.boundingSphere.center = target.position;
	}

	function getTargetPositionRange(range) {
		let output = range / 2 - config.scene.targetCage.radius;

		if (range < 0) {
			return config.scene.targetCage.radius;
		}

		return output
	}

	function adjustGUIRanges() {
		if (!guiTargetCageRadius || !guiTargetRadius) {
			return;
		}

		guiTargetCageRadius.min(config.scene.target.radius).updateDisplay();
		guiTargetRadius.max(config.scene.targetCage.radius).updateDisplay();

		if (!guiTargetX || !targetYRange || !targetZRange) {
			return;
		}

		let targetXRange = getTargetPositionRange(config.scene.box.width);
		guiTargetX.min(-targetXRange).max(targetXRange).updateDisplay();

		let targetYRange = getTargetPositionRange(config.scene.box.height);
		guiTargetY.min(-targetYRange).max(targetYRange).updateDisplay();

		let targetZRange = getTargetPositionRange(config.scene.box.depth);
		guiTargetZ.min(-targetZRange).max(targetZRange).updateDisplay();
	}

	function toggleChartPoints() {
		chart.internal.config.point_show = config.chart.showPoints;
	}

	function resetAnimation() {
		// Stop the animation
		window.cancelAnimationFrame(animationFrame);

		removeSceneObjects();

		// Reset globals. This is super-clumsy and needs refactoring!
		particles = [];
		particleBatches = [];
		visibleParticles = [];
		particlesInBox = 0;
		particlesInTarget = 0;
		currentParticleBatch = 0;
		elapsed = 0;

		initSceneObjects();

		chart = chart.destroy();
		initChart();

		adjustColors();

		adjustGUIRanges();

		// Restart the animation
		renderLoop();
	}

	function rememberGUISettings() {
		// Invoking gui.remember() at least once will show the save menu.
		// Note that changing presets will fire the event handlers for all the configuration options
		// which reloads all the UI items multiple times quickly via resetAnimation. This is not ideal.
		gui.remember(config);

		// Descend recursively through all the subobjects of the config and inform the GUI of their existence.
		let descender = (obj) => {
			Object.keys(obj).forEach(key => {
				if (typeof obj[key] === "object") {
					gui.remember(obj[key]);

					descender(obj[key]);
				}
			});
		};

		descender(config);
	}

	function toggleCage() {
		targetCage.visible = !targetCage.visible;
	}

	function toggleChart() {
		// For some reason `chart.toggle('', {withLegend: true})` doesn't work :(
		let c = document.getElementById('chart');
		if (!c.style.visibility || c.style.visibility == 'visible') {
			chart.hide('', {withLegend: true});
			c.style.visibility = 'hidden';
		} else {
			chart.show('', {withLegend: true});
			c.style.visibility = 'visible';
		}
	}

	function toggleStats() {
		if (!stats.dom.style.visibility || stats.dom.style.visibility == 'visible') {
			stats.dom.style.visibility = "hidden";
		} else {
			stats.dom.style.visibility = "visible";
		}
	}

	function saveData() {
		// Set the header of the CSV file
		let payload = '"% FOV","% ROI","Time interval"';

		let bodyValues = chart.data('body')[0].values;
		let targetValues = chart.data('target')[0].values;

		// Write the values wrapped in quotes, just in case some computer locale
		// uses commas as the decimal separator.
		for (let i = 0; i < bodyValues.length; i++) {
			payload += '\n"' + bodyValues[i].value.toString() + '","' + targetValues[i].value.toString() + '","' + (i+1).toString() + '"';
		}

		// Create a dummy anchor element
		let downloadAnchor = window.document.createElement('a');
		downloadAnchor.href = window.URL.createObjectURL(new Blob([payload], { type: 'text/csv' }));
		downloadAnchor.download = 'data.csv';

		// Append anchor to body
		document.body.appendChild(downloadAnchor);

		// Trigger download
		downloadAnchor.click();

		// Remove anchor from body
		document.body.removeChild(downloadAnchor);
	}

	function toggleInfo() {
		let infoBox = document.getElementById('info');
		if (!infoBox.style.display || infoBox.style.display === 'none') {
			infoBox.style.display = 'block';
			infoBox.parentNode.style.display = 'block';
			window.setTimeout(function(){
				infoBox.style.opacity = 1;
				infoBox.style.transform = 'translate(-50%, -50%) scale(1)';
				infoBox.parentNode.style.opacity = 1;
			}, 25); // Fire the animation with a slight delay because otherwise the browser might skip it
		} else {
			infoBox.style.opacity = 0;
			infoBox.style.transform = 'translate(-50%, -50%) scale(1.1)';
			infoBox.parentNode.style.opacity = 0;
			window.setTimeout(function(){
				infoBox.style.display = 'none';
				infoBox.parentNode.style.display = 'none';
			}, 200);
		}
	}

	function initGUI() {
		// Inspired from https://stackoverflow.com/questions/27362914/how-to-add-tooltips-to-dat-gui
		// dat.GUI copies the prototype of superclass Controller to all other controllers so it
		// is not enough to add it only to the super class as the reference is not maintained.
		for (let controllerName in dat.controllers) {
			if (dat.controllers.hasOwnProperty(controllerName)) {
				if (!dat.controllers[controllerName].prototype.hasOwnProperty('title')) {
					dat.controllers[controllerName].prototype.title = function(v) {
						// __li is the root dom element of each controller
						if (v) {
							this.__li.setAttribute('title', v);
						} else {
							this.__li.removeAttribute('title')
						}
						return this;
					};
				}
			}
		}

		dat.GUI.DEFAULT_WIDTH = config.gui.width;
		gui = new dat.GUI({ load: presets });

		rememberGUISettings();

		let sceneFolder = gui.addFolder('Simulation settings');
		sceneFolder.open();

		// let backgroundFolder = sceneFolder.addFolder('Background');
		// backgroundFolder.addColor(config.scene.background, 'color').onChange(adjustColors);

		let boxFolder = sceneFolder.addFolder('FOV');
		// boxFolder.addColor(config.scene.box, 'color').onChange(adjustColors);
		// boxFolder.addColor(config.scene.box, 'edgesColor').onChange(adjustColors);
		// boxFolder.add(config.scene.box, 'opacity', 0.01, 1).onChange(adjustOpacities);
		boxFolder.add(config.scene.box, 'width', 0.3, 2).name('Width').onFinishChange(resetAnimation);
		boxFolder.add(config.scene.box, 'height', 0.3, 2).name('Height').onFinishChange(resetAnimation);
		boxFolder.add(config.scene.box, 'depth', 0.3, 2).name('Depth').onFinishChange(resetAnimation);

		let targetFolder = sceneFolder.addFolder('ROI');
		// targetFolder.addColor(config.scene.target, 'color').onChange(adjustColors);
		// dat.gui sets the implicit step value to 1 for x, y and z due to their initial value
		// TODO: Adjust the ranges for guiTargetRadius and guiTargetCageRadius dynamically when re-enabling these
		// let targetXRange = getTargetPositionRange(config.scene.box.width);
		// guiTargetX = targetFolder.add(config.scene.target, 'x', -targetXRange, targetXRange).step(0.0001).onChange(adjustTargetPosition).onFinishChange(resetAnimation);
		// let targetYRange = getTargetPositionRange(config.scene.box.height);
		// guiTargetY = targetFolder.add(config.scene.target, 'y', -targetYRange, targetYRange).step(0.0001).onChange(adjustTargetPosition).onFinishChange(resetAnimation);
		// let targetZRange = getTargetPositionRange(config.scene.box.depth);
		// guiTargetZ = targetFolder.add(config.scene.target, 'z', -targetZRange, targetZRange).step(0.0001).onChange(adjustTargetPosition).onFinishChange(resetAnimation);
		// targetFolder.add(config.scene.target, 'opacity', 0.01, 1).onChange(adjustOpacities);
		guiTargetRadius = targetFolder.add(config.scene.target, 'radius', 0.02, config.scene.targetCage.radius).name('Radius').onFinishChange(resetAnimation);
		// targetFolder.add(config.scene.target, 'viscosity', 0, 0.9).onFinishChange(resetAnimation);
		// targetFolder.add(config.scene.target, 'shininess', 0, 100).onChange(adjustTargetShininess);
		// targetFolder.addColor(config.scene.target, 'emissiveColor').name('glowColor').onChange(adjustColors);
		// targetFolder.add(config.scene.target, 'emissiveIntensityMax', 0.2, 2).name('glowMaxValue').onFinishChange(resetAnimation);

		let targetCageFolder = sceneFolder.addFolder('EPR zone');
		// targetCageFolder.addColor(config.scene.targetCage, 'color').onChange(adjustColors);
		// targetCageFolder.add(config.scene.targetCage, 'opacity', 0.01, 1).onChange(adjustOpacities);
		let maxTargetCageRadius = Math.min(config.scene.box.width, config.scene.box.height, config.scene.box.depth) / 2;
		guiTargetCageRadius = targetCageFolder.add(config.scene.targetCage, 'radius', config.scene.target.radius, maxTargetCageRadius).name('Radius').onFinishChange(resetAnimation);
		// targetCageFolder.add(config.scene.targetCage, 'viscosity', 0, 0.9).onFinishChange(resetAnimation);
		// targetCageFolder.add(config.scene.targetCage, 'rotationSpeed', 0, 0.05);
		// targetCageFolder.add(config.scene.targetCage, 'particleCaptureProbability', 0, 1).onFinishChange(resetAnimation);
		// targetCageFolder.add(config.scene.targetCage, 'gravity', 0.0001, 0.1).onFinishChange(resetAnimation);
		targetCageFolder.add(config.scene.targetCage, 'cageEnabled').name('EPR zone enabled').onFinishChange(toggleCage);

		// let tubesFolder = sceneFolder.addFolder('Tubes');
		// tubesFolder.addColor(config.scene.tubes, 'color').onChange(adjustColors);
		// tubesFolder.addColor(config.scene.tubes, 'edgesColor').onChange(adjustColors);
		// tubesFolder.add(config.scene.tubes, 'height', 0.1, 0.5).onFinishChange(resetAnimation);
		// tubesFolder.add(config.scene.tubes, 'radius', 0.01, 0.05).onFinishChange(resetAnimation);
		// tubesFolder.add(config.scene.tubes, 'verticalDisplacement', 0.1, 0.9).onFinishChange(resetAnimation);

		let particlesFolder = sceneFolder.addFolder('Fluorescent agent');
		// particlesFolder.addColor(config.scene.particles, 'color').onChange(adjustColors);
		particlesFolder.add(config.scene.particles, 'changeColor').name('Off/On responsive').title('Flu off/on response enabled').onFinishChange(adjustOpacities);
		particlesFolder.add(config.scene.particles, 'particlesInvisibleInBox').name('Invisible in FOV').onFinishChange(toggleParticlesInBoxVisibility);
		// particlesFolder.addColor(config.scene.particles, 'colorInTarget').onChange(adjustColors);
		particlesFolder.add(config.scene.particles, 'radius', 0.001, 0.02).name('Radius').onFinishChange(resetAnimation);
		particlesFolder.add(config.scene.particles, 'count', 1, 10000).name('Count').step(1).onFinishChange(resetAnimation);
		// particlesFolder.add(config.scene.particles, 'opacityInBox', 0, 1).name('Opacity').onChange(adjustOpacities);
		// particlesFolder.add(config.scene.particles, 'batchSize', 1, 100).step(1).onFinishChange(resetAnimation);
		// particlesFolder.add(config.scene.particles, 'batchDelay', 5, 120).step(1).onFinishChange(resetAnimation);
		// particlesFolder.add(config.scene.particles, 'velocityMin', SCENE_SCALE / 2000, SCENE_SCALE / 500).onFinishChange(resetAnimation);
		// particlesFolder.add(config.scene.particles, 'velocityMax', SCENE_SCALE / 500, SCENE_SCALE / 50).onFinishChange(resetAnimation);

		let excretionFolder = sceneFolder.addFolder('FOV clearance');
		excretionFolder.add(config.excretion, 'initialDelay', 120, 600).name('Initial delay').step(1).onFinishChange(resetAnimation);
		excretionFolder.add(config.excretion, 'rate', 1, 250).name('Rate').step(1).onFinishChange(resetAnimation);
		// excretionFolder.add(config.excretion, 'delay', 5, 120).step(1).onFinishChange(resetAnimation);

		let targetExcretionFolder = sceneFolder.addFolder('ROI clearance');
		targetExcretionFolder.add(config.targetExcretion, 'initialDelay', 120, 1200).name('Initial delay').step(1).onFinishChange(resetAnimation);
		targetExcretionFolder.add(config.targetExcretion, 'rate', 1, 250).name('Rate').step(1).onFinishChange(resetAnimation);
		// targetExcretionFolder.add(config.targetExcretion, 'delay', 5, 120).step(1).onFinishChange(resetAnimation);

		// let chartFolder = sceneFolder.addFolder('Chart');
		// chartFolder.addColor(config.chart, 'bodyPlotColor').onChange(adjustColors);
		// chartFolder.addColor(config.chart, 'targetPlotColor').onChange(adjustColors);
		// chartFolder.addColor(config.chart, 'axesColor').onChange(adjustColors);
		// chartFolder.addColor(config.chart, 'textElementsColor').onChange(adjustColors);
		// chartFolder.add(config.chart, 'showPoints').onChange(toggleChartPoints);
		// chartFolder.add(config.chart, 'sampleInterval', 10, 180).step(1).onFinishChange(resetAnimation);
		// chartFolder.add(config.chart, 'transitionDuration', 0, 400).step(1).onFinishChange(resetAnimation);
		// chartFolder.add(config.chart, 'exclusivePlots').onFinishChange(resetAnimation);

		gui.add({ toggle: toggleChart }, 'toggle').name('Toggle chart');

		// gui.add({ toggle: toggleStats }, 'toggle').name('Toggle stats');

		let pause = gui.add(window, 'pauseAnimation').name('Pause simulation').listen();
		pause.isModified = function() { return false; };

		gui.add({ reset: resetAnimation }, 'reset').name('Restart simulation').onChange(function() {
			// Unpause animation when this button is pressed
			window.pauseAnimation = false;
		});

		// Hack: Also unpause animation when changing presets
		let select = document.getElementsByClassName('save-row')[0].getElementsByTagName('select')[0];
		dat.dom.dom.bind(select, 'change', function () { window.pauseAnimation = false; })

		gui.add({ save: saveData }, 'save').name('Save data');

		gui.add({ info: toggleInfo }, 'info').name('Info');

		// Disable overwriting of existing presets
		let originalSaveButton = document.getElementsByClassName('save')[0];
		let saveButton = originalSaveButton.cloneNode(true);
		originalSaveButton.parentNode.replaceChild(saveButton, originalSaveButton);
		saveButton.addEventListener('click', function() {
			var selectedPreset = select.options[select.selectedIndex].value;

			if (originalPresets.includes(selectedPreset)) {
				alert('Can\'t overwrite original presets. Click on New and save as new simulation or click on Revert to restore original presets.');
				return;
			}

			gui.save();
		}, false);
	}

	function initParticle(p) {
		// Inject particles from the centre of the left side face of the box
		p.position.x = -box.geometry.parameters.width / 2;
		p.position.y = config.scene.box.height / 2 * config.scene.tubes.verticalDisplacement;
		p.position.z = 0;

		p.velocity = getRandomVelocity();

		p.visible = false; // Show the particles later, in batches
		p.isExcreted = false;

		p.isInTarget = false; // Inside the target sphere

		// Disable culling (we don't need to hide particles that go out of view)
		p.frustumCulled = false;

		return p;
	}

	function addParticlesToScene(count) {
		let geometry = new THREE.SphereBufferGeometry(config.scene.particles.radius, 32, 32);

		for (let i = 0; i < count; i++) {
			let p = initParticle(
				new THREE.Mesh(
					geometry,
					new THREE.MeshBasicMaterial({
						color: config.scene.particles.color,
						opacity: config.scene.particles.opacityInBox,
						transparent: config.scene.particles.changeColor,
					}),
				),
			);

			particles.push(p);

			scene.add(p);
		}
	}

	function computeParticleBatches() {
		let batch = [];
		for (let i = 0; i < config.scene.particles.count; i++) {
			batch.push(particles[i]);

			if (batch.length == config.scene.particles.batchSize) {
				particleBatches.push(batch);
				batch = [];
			}
		}

		if (batch.length > 0) {
			particleBatches.push(batch);
		}
	}

	function initChart() {
		chart = c3.generate({
			bindto: '#chart',
			axis: {
				x: {
					min: 0,
					height: 45,
					padding: {left: 0, right: 0},
					tick: {
						// Don't show a tick line for each datapoint
						fit: false,
					},
					label: {
						text: 'Time (samples)',
						position: "outer-right",
					},
				},
				y: {
					min: 0,
					max: 100,
					padding: {bottom: 0, top: 0},
					label: {
						text: 'Relative % fluorophore',
						position: 'outer-top',
					},
				},
			},
			grid: {
				x: {
					show: true,
				},
				y: {
					show: true,
				},
			},
			point: {
				show: config.chart.showPoints,
			},
			data: {
				columns: [
					['body',   0],
					['target', 0],
				],
				colors: {
					'body':   config.chart.bodyPlotColor,
					'target': config.chart.targetPlotColor,
				},
				names: {
					body:   '% in FOV',
					target: '% in ROI',
				},
			},
			legend: {
				position: 'bottom',
				item: {
					tile: {
						width: 50,
						height: 1,
					},
				},
			},
			transition: {
				duration: config.chart.transitionDuration,
			},
			title: {
				text: '% FOV / ROI distributions over time',
			},
		});
		let c = document.getElementById('chart');
		if (c.style.visibility && c.style.visibility != 'visible') {
			c.style.visibility = 'visible';
		}
	}

	function init() {
		config = new Config();

		scene = new THREE.Scene();
		scene.background = new THREE.Color(config.scene.background.color);

		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio);

		let animationContainer = document.getElementById('animation');
		animationContainer.appendChild(renderer.domElement);

		let bbClientRect = renderer.domElement.getBoundingClientRect();
		// Use the default values from the PerspectiveCamera constructor
		camera = new THREE.PerspectiveCamera(50, bbClientRect.width / bbClientRect.height, 0.1, 2000);
		camera.position.z = SCENE_SCALE * 2;
		camera.position.x = SCENE_SCALE * 0.7;
		camera.position.y = SCENE_SCALE * 0.1;
		camera.updateProjectionMatrix();

		renderer.setSize(bbClientRect.width, bbClientRect.height);
		window.addEventListener('resize', function() {
			renderer.setSize(animationContainer.offsetWidth, animationContainer.offsetHeight);
		});

		controls = new THREE.OrbitControls(camera, renderer.domElement);
		//controls.enableZoom = false;

		stats = new Stats();
		animationContainer.appendChild(stats.dom);

		initSceneObjects();

		initGUI();

		initChart();

		adjustColors();

		renderLoop();
	}

	function initSceneObjects() {
		box = new THREE.Mesh(
			new THREE.BoxBufferGeometry(config.scene.box.width, config.scene.box.height, config.scene.box.depth),
			new THREE.MeshBasicMaterial({
				color: config.scene.box.color,
				transparent: true,
				opacity: config.scene.box.opacity,
				depthTest: false,
			}),
		);
		boxEdges = new THREE.LineSegments(
			new THREE.EdgesGeometry(box.geometry), // or WireframeGeometry
			new THREE.LineBasicMaterial({ color: config.scene.box.edgesColor }),
		);
		box.add(boxEdges);
		scene.add(box);

		targetCage = new THREE.Mesh(
			new THREE.SphereBufferGeometry(config.scene.targetCage.radius),
			new THREE.MeshBasicMaterial({
				color: config.scene.targetCage.color,
				wireframe: true,
				transparent: true,
				opacity: config.scene.targetCage.opacity,
			}),
		);
		// Helps avoid some unexpected culling when placed towards the top of the scene
		targetCage.frustumCulled = false;

		targetCage.geometry.computeBoundingSphere();

		targetCage.visible = config.scene.targetCage.cageEnabled;

		box.add(targetCage);

		target = new THREE.Mesh(
			new THREE.SphereBufferGeometry(config.scene.target.radius, 30, 30),
			new THREE.MeshPhongMaterial ({
				color: config.scene.target.color,
				shininess: config.scene.target.shininess,
				emissive: config.scene.target.emissiveColor,
				emissiveIntensity: 0, // Will be updated when particles start to enter the target
				transparent: true,
				opacity: config.scene.target.opacity,
			})
		);
		// Helps avoid some unexpected culling when placed towards the top of the scene
		target.frustumCulled = false;

		target.geometry.computeBoundingSphere();
		// Hack the bounding sphere radius to force the particles to remain fully contained in the target
		target.geometry.boundingSphere.radius -= config.scene.particles.radius;

		box.add(target);

		// Set the initial position of the target
		adjustTargetPosition();

		inputTube = new THREE.Mesh(
			new THREE.CylinderBufferGeometry(config.scene.tubes.radius, config.scene.tubes.radius, config.scene.tubes.height, 8, 1, false, 0.0, Math.PI * 2),
			new THREE.MeshBasicMaterial({ color: config.scene.tubes.color, transparent: true, opacity: 0.5 }),
		);
		inputTube.position.x = -box.geometry.parameters.width / 2 - config.scene.tubes.height / 2;
		inputTube.position.y = config.scene.box.height / 2 * config.scene.tubes.verticalDisplacement;
		inputTube.rotation.x = Math.PI / 2;
		inputTube.rotation.z = Math.PI / 2;
		inputTubeEdges = new THREE.LineSegments(
			new THREE.WireframeGeometry(inputTube.geometry), // or EdgesGeometry
			new THREE.LineBasicMaterial({ color: config.scene.tubes.color }),
		);
		inputTube.add(inputTubeEdges);
		scene.add(inputTube);

		outputTube = new THREE.Mesh(
			new THREE.CylinderBufferGeometry(config.scene.tubes.radius, config.scene.tubes.radius, config.scene.tubes.height, 8, 1, false, 0.0, Math.PI * 2),
			new THREE.MeshBasicMaterial({ color: config.scene.tubes.color, transparent: true, opacity: 0.5 }),
		);
		outputTube.position.x = box.geometry.parameters.width / 2 + config.scene.tubes.height / 2;
		outputTube.position.y = -config.scene.box.height / 2 * config.scene.tubes.verticalDisplacement;
		outputTube.rotation.x = Math.PI / 2;
		outputTube.rotation.z = Math.PI / 2;
		outputTubeEdges = new THREE.LineSegments(
			new THREE.WireframeGeometry(outputTube.geometry), // or EdgesGeometry
			new THREE.LineBasicMaterial({ color: config.scene.tubes.color })
		);
		outputTube.add(outputTubeEdges);
		scene.add(outputTube);

		addParticlesToScene(config.scene.particles.count);

		computeParticleBatches();

		// DirectionalLight is a plane of light which emits from both sides
		let light = new THREE.DirectionalLight(new THREE.Color('white'), 0.7);
		// Position it in front of everything
		light.position.set(0, 0, SCENE_SCALE);
		scene.add(light);

		// Extra knob to adjust the lights hitting the objects
		let ambientLight = new THREE.AmbientLight(new THREE.Color('white'), 0.7);
		scene.add(ambientLight);
	}

	function removeSceneObjects() {
		while (scene.children.length)
		{
			let child = scene.children[0];
			disposeObject(child);
			scene.remove(child);
			child = undefined;
		}

		renderer.clear();
	}

	// Code ripped off from here https://github.com/mrdoob/three.js/issues/5175#issuecomment-316744586
	function disposeObject(obj, unset=false) {
		if (obj !== null) {
			for (let i = 0; i < obj.children.length; i++) {
				disposeObject(obj.children[i], true);
			}

			if (obj.geometry) {
				obj.geometry.dispose();
				obj.geometry = undefined;
			}

			if (obj.material) {
				if (obj.material.map) {
					obj.material.map.dispose();
					obj.material.map = undefined;
				}
				obj.material.dispose();
				obj.material = undefined;
			}
		}

		if (unset) {
			obj = undefined;
		}
	};
</script>

<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-151736595-1"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-151736595-1');
</script>

</head>

<body onload="init()">
	<div class="container">
		<div id="animation"></div>
		<div class="chart-container">
			<div id="chart"></div>
		</div>
	</div>
	<div class="info-wrapper" onclick="toggleInfo()">
		<div id="info" onclick="event.stopPropagation();">
			© <a href="https://www.rcsi.com/dublin/about/faculty-of-medicine-and-health-sciences/academic-departments/chemistry">Department Of Chemistry</a>, Royal College of Surgeons in Ireland, 2019

			Source code: <a href="https://github.com/mihaitodor/particle_simulation">https://github.com/mihaitodor/particle_simulation</a>


			<button onclick="toggleInfo()">Close</button></div>
	<div>
</body>
</html>