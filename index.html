<!DOCTYPE html>

<html>

<head>
	<meta charset="UTF-8">
	<title>Particle Simulation</title>

<style>
	* {
		margin: 0;
	}

	html, body {
		height: 100%;
	}

	.container {
		height: 100%;
		margin: 0px auto;
		overflow: hidden;
    }

    #animation {
    	display: block;
    	height: 100%;
    	width: 100%;
    }

    canvas {
		display: block; /* The default display, inline, would add small margin below the canvas */
		height: 100%;
		width: 100%;
	}
</style>

<script src="js/three.min.js"></script>
<script src="js/OrbitControls.js"></script>
<script src="js/stats.min.js"></script>
<script src="js/dat.gui.min.js"></script>

<script>
	"use strict";

	console.clear();

	const SCENE_SCALE = 1;

	let Config = function() {
		this.scene = {
			box: {
				height: 1.5,
				aspectRatio: 0.6,
			},
			tubes: {
				height: 0.2,
				radius: 0.025,
				verticalDisplacement: 0.75,
			},
			particles: {
				color: '#' + new THREE.Color('red').getHexString(),
				size: 0.0035,
				count: 1000,
				batchSize: 10,
				batchDelay: 15,
				velocityMin: SCENE_SCALE / 1000,
				velocityMax: SCENE_SCALE / 100,
				timeInBody: 1000,
			}
		};
	};

	// Handles which need to be accessed when rendering frames
	let scene, camera, renderer, controls, stats, gui, config;

	// Scene objects
	let box, regionOfInfluence, target, particles = [], particleBatches = [], visibleParticles = [], currentParticleBatch = 0;

	// Keep track of elapsed frames
	let elapsed = 0;

	// Return a random value in interval [-max, -min) \cup [min, max)
	// TODO: Avoid calling Math.random() twice
	function getRandomValueWithGap(min, max, positiveOnly = false) {
		let rand = Math.random();

		let value = rand * (max - min) + min;

		if (positiveOnly || rand > 0.5) {
			return value;
		}

		return -value;
	};

	function getRandomVelocity() {
		return new THREE.Vector3(
			getRandomValueWithGap(config.scene.particles.velocityMin, config.scene.particles.velocityMax, true),
			getRandomValueWithGap(config.scene.particles.velocityMin, config.scene.particles.velocityMax),
			getRandomValueWithGap(config.scene.particles.velocityMin, config.scene.particles.velocityMax),
		);
	}

	// Check to see if the position of the ball doesn't go past the box wall and
	// also check to see if it's velocity is less than or greater than 0 so it
	// doesn't spike past and get stuck by the edge of the wall.
	function handleBoxWallColisions(p) {
		if(p.position.x >= box.geometry.parameters.width / 2 - p.geometry.parameters.radius && p.velocity.x > 0 || p.position.x <= -box.geometry.parameters.width / 2 + p.geometry.parameters.radius && p.velocity.x < 0)
			p.velocity.setX(-p.velocity.x);

		if(p.position.y >= box.geometry.parameters.height / 2 - p.geometry.parameters.radius && p.velocity.y > 0 || p.position.y <= -box.geometry.parameters.height / 2 + p.geometry.parameters.radius && p.velocity.y < 0)
			p.velocity.setY(-p.velocity.y);

		if(p.position.z >= box.geometry.parameters.depth / 2 - p.geometry.parameters.radius && p.velocity.z > 0 || p.position.z <= -box.geometry.parameters.depth / 2 + p.geometry.parameters.radius && p.velocity.z < 0)
			p.velocity.setZ(-p.velocity.z);
	}

	function handleSphereWallColisions(p) {
		let normal = new THREE.Vector3();
		normal.subVectors(p.position, target.geometry.boundingSphere.center).normalize();
		p.velocity = p.velocity.reflect(normal);
	}

	function updateObjects() {
		regionOfInfluence.rotation.y += 0.005;

		// Release a new batch of particles
		if (elapsed % config.scene.particles.batchDelay === 0 && currentParticleBatch < particleBatches.length) {
			let batch = particleBatches[currentParticleBatch];

			for (let i = 0; i < batch.length; i++) {
				let p = batch[i];
				p.visible = true;
				p.position.add(p.velocity); // Start moving the particles as soon as they become visible
				visibleParticles.push(p);
			}

			currentParticleBatch++;
		}

		// Animate particles
		for (let i = 0; i < visibleParticles.length; i++) {
			let p = visibleParticles[i];
			p.position.add(p.velocity);

			// if (regionOfInfluenceSphere.containsPoint(p.position)) {
			// 	p.isInROI = true;
			// }

			if (p.isInTarget || p.position.distanceTo(target.geometry.boundingSphere.center) < target.geometry.boundingSphere.radius) {
				p.isInTarget = true;
				handleSphereWallColisions(p);
				continue;
			}

			handleBoxWallColisions(p);
		}
	}

	function renderLoop() {
		requestAnimationFrame(renderLoop);

		updateObjects();

		renderer.render(scene, camera);
		controls.update();
		stats.update();

		elapsed += 1;
	}

	function adjustParticleColor() {
		for (let i = 0; i < particleBatches.length; i++) {
			for (let j = 0; j < particleBatches[i].length; j++) {
				particleBatches[i][j].material.color.set(config.scene.particles.color);
			}
		}
	}

	function adjustParticleSize() {
		console.log("TODO adjustParticleSize");
	}

	function resetAnimation() {
		if (particles.length < config.scene.particles.count) {
			addParticlesToScene(config.scene.particles.count - particles.length);
		}

		for (let i = 0; i < visibleParticles.length; i++) {
			initParticle(visibleParticles[i]);
		}

		visibleParticles = [];

		particleBatches = [];
		currentParticleBatch = 0;

		computeParticleBatches();

		//elapsed = 0; // Probably not useful
	}

	function initGUI() {
		gui = new dat.GUI();

		// Save the config to localStorage
		gui.remember(config);

		let sceneFolder = gui.addFolder('Scene');
		let boxFolder = sceneFolder.addFolder('Box');
		boxFolder.add(config.scene.box, 'height', 1, 2).onFinishChange(resetAnimation);
		boxFolder.add(config.scene.box, 'aspectRatio', 0.3, 1).onFinishChange(resetAnimation);

		let tubesFolder = sceneFolder.addFolder('Tubes');
		tubesFolder.add(config.scene.tubes, 'height', 0.1, 0.5).onFinishChange(resetAnimation);
		tubesFolder.add(config.scene.tubes, 'radius', 0.01, 0.05).onFinishChange(resetAnimation);
		tubesFolder.add(config.scene.tubes, 'verticalDisplacement', 0.1, 0.9).onFinishChange(resetAnimation);

		let particlesFolder = sceneFolder.addFolder('Particles');
		particlesFolder.addColor(config.scene.particles, 'color').onChange(adjustParticleColor);
		particlesFolder.add(config.scene.particles, 'size', 0.001, 0.01).onChange(adjustParticleSize);
		particlesFolder.add(config.scene.particles, 'count', 1, 3000).step(1).onFinishChange(resetAnimation);
		particlesFolder.add(config.scene.particles, 'batchSize', 1, 100).step(1).onFinishChange(resetAnimation);
		particlesFolder.add(config.scene.particles, 'batchDelay', 5, 40).step(1).onFinishChange(resetAnimation);
		particlesFolder.add(config.scene.particles, 'timeInBody', 100, 3000).onFinishChange(resetAnimation);
		// TODO: adjust these dynamically?
		particlesFolder.add(config.scene.particles, 'velocityMin', SCENE_SCALE / 2000, SCENE_SCALE / 500).onFinishChange(resetAnimation);
		particlesFolder.add(config.scene.particles, 'velocityMax', SCENE_SCALE / 500, SCENE_SCALE / 50).onFinishChange(resetAnimation);
	}

	function initParticle(p) {
		// Inject particles from the centre of the left side face of the box
		p.position.x = -box.geometry.parameters.width / 2;
		p.position.y = config.scene.box.height / 2 * config.scene.tubes.verticalDisplacement;

		p.velocity = getRandomVelocity();

		p.visible = false; // Show the particles later, in batches

		p.isInROI = false; // Inside the region of influence
		p.isInTarget = false; // Inside the target sphere

		return p;
	}

	function addParticlesToScene(count) {
		let geometry = new THREE.SphereBufferGeometry(SCENE_SCALE * config.scene.particles.size, 32, 32);
		let material = new THREE.MeshBasicMaterial({
			color: config.scene.particles.color
		});

		for (let i = 0; i < count; i++) {
			let p = initParticle(new THREE.Mesh(geometry, material));

			particles.push(p);

			scene.add(p);
		}
	}

	function computeParticleBatches() {
		let batch = [];
		for (let i = 0; i < config.scene.particles.count; i++) {
			batch.push(particles[i]);

			if (batch.length == config.scene.particles.batchSize) {
				particleBatches.push(batch);
				batch = [];
			}
		}

		if (batch.length > 0) {
			particleBatches.push(batch);
		}
	}

	function init() {
		config = new Config();

		scene = new THREE.Scene();
		scene.background = new THREE.Color('white')

		renderer = new THREE.WebGLRenderer({ antialias: true });
		renderer.setPixelRatio(window.devicePixelRatio);

		let animationContainer = document.getElementById('animation');
		animationContainer.appendChild(renderer.domElement);

		stats = new Stats();
		animationContainer.appendChild(stats.dom);

		initGUI();

		let bbClientRect = renderer.domElement.getBoundingClientRect();
		// Use the default values from the PerspectiveCamera constructor
		camera = new THREE.PerspectiveCamera(50, bbClientRect.width / bbClientRect.height, 0.1, 2000);
		camera.position.z = SCENE_SCALE * 2;
		camera.position.x = SCENE_SCALE * 0.7;
		camera.position.y = SCENE_SCALE * 0.1;
		camera.updateProjectionMatrix();

		renderer.setSize(bbClientRect.width, bbClientRect.height);
		window.addEventListener('resize', function() {
			renderer.setSize(animationContainer.offsetWidth, animationContainer.offsetHeight);
		});

		controls = new THREE.OrbitControls(camera, renderer.domElement);
		//controls.enableZoom = false;

		box = new THREE.Mesh(
			new THREE.BoxBufferGeometry(config.scene.box.aspectRatio * SCENE_SCALE, config.scene.box.height * SCENE_SCALE, config.scene.box.aspectRatio * SCENE_SCALE),
			new THREE.MeshBasicMaterial({ color: new THREE.Color('red'), transparent: true, opacity: 0.1, depthTest: false }),
		);
		let boxEdges = new THREE.LineSegments(
			new THREE.EdgesGeometry(box.geometry), // or WireframeGeometry
			new THREE.LineBasicMaterial({ color: new THREE.Color('red') }),
		);
		box.add(boxEdges);
		scene.add(box);

		regionOfInfluence = new THREE.Mesh(
			new THREE.SphereBufferGeometry(SCENE_SCALE * 0.2),
			new THREE.MeshBasicMaterial({ color: new THREE.Color('gray'), wireframe: true }),
		);
		box.add(regionOfInfluence);

		target = new THREE.Mesh(
			new THREE.SphereBufferGeometry(SCENE_SCALE * 0.1, 30, 30),
			new THREE.MeshPhongMaterial ({
				color: new THREE.Color('gray'),
				shininess: 30, // Default 30
				// emissive: new THREE.Color('springgreen'),
				// emissiveIntensity: 0.15,
				transparent: true,
				opacity: 0.8,
			})
		);

		target.geometry.computeBoundingSphere();

		regionOfInfluence.add(target);

		let inputTube = new THREE.Mesh(
			new THREE.CylinderBufferGeometry(config.scene.tubes.radius, config.scene.tubes.radius, config.scene.tubes.height, 8, 1, false, 0.0, Math.PI * 2),
			new THREE.MeshBasicMaterial({ color: new THREE.Color('red'), transparent: true, opacity: 0.5 }),
		);
		inputTube.position.x = -box.geometry.parameters.width / 2 - config.scene.tubes.height / 2;
		inputTube.position.y = config.scene.box.height / 2 * config.scene.tubes.verticalDisplacement;
		inputTube.rotation.x = Math.PI / 2;
		inputTube.rotation.z = Math.PI / 2;
		let inputTubeEdges = new THREE.LineSegments(
			new THREE.WireframeGeometry(inputTube.geometry), // or EdgesGeometry
			new THREE.LineBasicMaterial({ color: new THREE.Color('red') }),
		);
		inputTube.add(inputTubeEdges);
		scene.add(inputTube);

		let outputTube = new THREE.Mesh(
			new THREE.CylinderBufferGeometry(config.scene.tubes.radius, config.scene.tubes.radius, config.scene.tubes.height, 8, 1, false, 0.0, Math.PI * 2),
			new THREE.MeshBasicMaterial({ color: new THREE.Color('red'), transparent: true, opacity: 0.5 }),
		);
		outputTube.position.x = box.geometry.parameters.width / 2 + config.scene.tubes.height / 2;
		outputTube.position.y = -config.scene.box.height / 2 * config.scene.tubes.verticalDisplacement;
		outputTube.rotation.x = Math.PI / 2;
		outputTube.rotation.z = Math.PI / 2;
		let outputTubeEdges = new THREE.LineSegments(
			new THREE.WireframeGeometry(outputTube.geometry), // or EdgesGeometry
			new THREE.LineBasicMaterial({ color: new THREE.Color('red') })
		);
		outputTube.add(outputTubeEdges);
		scene.add(outputTube);

		addParticlesToScene(config.scene.particles.count);

		computeParticleBatches();

		// DirectionalLight is a plane of light which emits from both sides
		let light = new THREE.DirectionalLight(new THREE.Color('white'), 0.7);
		// Position it in front of everything
		light.position.set(0, 0, SCENE_SCALE);
		scene.add(light);

		// Extra knob to adjust the lights hitting the objects
		let ambientLight = new THREE.AmbientLight(new THREE.Color('white'), 0.7);
		scene.add(ambientLight);

		renderLoop();
	}

</script>
</head>

<body onload="init()">
	<div class="container">
		<div id="animation"></div>
		<div id="chart"></div>
	</div>
</body>
</html>